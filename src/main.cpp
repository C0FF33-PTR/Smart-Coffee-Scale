
#include <HX711_ADC.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#if defined(ESP8266)|| defined(ESP32) || defined(AVR)
#include <EEPROM.h>
#endif

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define SCREEN_I2C_ADDRESS 0x3C
#define SCREEN_RESET_PIN -1

#define BIG_SCALE_HX711_dout 1 //mcu > HX711 dout pin, must be external interrupt capable!
#define BIG_SCALE_HX711_sck 2 //mcu > HX711 sck pin
#define SMALL_SCALE_HX711_dout 3 //mcu > HX711 dout pin, must be external interrupt capable!
#define SMALL_SCALE_HX711_sck 4 //mcu > HX711 sck pin

#define sendDataPin 6
#define swapLoadCellPin 7
#define powerPin 10
#define tarePin 20

typedef enum {
  bigLoadCell = 0x00,
  smallLoadCell = 0x01
} load_cell;

load_cell currentLoadCell = smallLoadCell;

void swapLoadCell(load_cell loadCell);
void drawHeader();
Adafruit_SSD1306 screen(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, SCREEN_RESET_PIN);

//HX711 constructor:
HX711_ADC BigCell(BIG_SCALE_HX711_dout, BIG_SCALE_HX711_sck);

//HX711 constructor:
HX711_ADC SmallCell(SMALL_SCALE_HX711_dout, SMALL_SCALE_HX711_sck);

const unsigned char power_icon[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x03, 0xc0, 0x00, 
	0x00, 0x03, 0xc0, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0xe3, 0xc7, 0x00, 
	0x01, 0xe3, 0xc7, 0x80, 0x03, 0xe3, 0xc7, 0xc0, 0x07, 0xc3, 0xc3, 0xe0, 0x07, 0x83, 0xc1, 0xe0, 
	0x0f, 0x03, 0xc0, 0xf0, 0x0e, 0x03, 0xc0, 0xf0, 0x0e, 0x03, 0xc0, 0x70, 0x1e, 0x03, 0xc0, 0x78, 
	0x1e, 0x00, 0x00, 0x78, 0x1e, 0x00, 0x00, 0x78, 0x1e, 0x00, 0x00, 0x78, 0x1e, 0x00, 0x00, 0x78, 
	0x0e, 0x00, 0x00, 0x70, 0x0e, 0x00, 0x00, 0x70, 0x0f, 0x00, 0x00, 0xf0, 0x07, 0x80, 0x01, 0xe0, 
	0x07, 0x80, 0x03, 0xe0, 0x03, 0xe0, 0x07, 0xc0, 0x01, 0xf8, 0x1f, 0x80, 0x00, 0xff, 0xff, 0x00, 
	0x00, 0x7f, 0xfe, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const unsigned char tare_icon[] PROGMEM = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x80, 
	0x00, 0xff, 0xff, 0x80, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x01, 0xc0, 0x00, 
	0x00, 0x01, 0xc0, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x01, 0xc0, 0x00, 
	0x00, 0x01, 0xc0, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x01, 0xc0, 0x00, 
	0x00, 0x01, 0xc0, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x01, 0xc0, 0x00, 
	0x00, 0x01, 0xc0, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x01, 0xc0, 0x00, 
	0x00, 0x01, 0xc0, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x01, 0xc0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const unsigned char swap_cell[] PROGMEM = {
  0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x03, 0x80, 
	0x00, 0x00, 0x01, 0xc0, 0x07, 0xff, 0xff, 0xe0, 0x07, 0xff, 0xff, 0xe0, 0x06, 0x00, 0x01, 0xc0, 
	0x06, 0x00, 0x03, 0x80, 0x06, 0x00, 0x07, 0x00, 0x06, 0x00, 0x0e, 0x00, 0x06, 0x00, 0x0c, 0x00, 
	0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x60, 
	0x00, 0x30, 0x00, 0x60, 0x00, 0x70, 0x00, 0x60, 0x00, 0xe0, 0x00, 0x60, 0x01, 0xc0, 0x00, 0x60, 
	0x03, 0x80, 0x00, 0x60, 0x07, 0xff, 0xff, 0xe0, 0x07, 0xff, 0xff, 0xe0, 0x03, 0x80, 0x00, 0x00, 
	0x01, 0xc0, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00
};

const unsigned char send_data_icon[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 
	0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 
	0x00, 0x04, 0x07, 0x00, 0x00, 0x0e, 0x07, 0x00, 0x00, 0x1e, 0x07, 0x00, 0x00, 0x3c, 0x07, 0x00, 
	0x00, 0x78, 0x07, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xfe, 0x00, 0x00, 0x7f, 0xf8, 0x00, 
	0x00, 0x38, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const unsigned char not_connected_icon[] PROGMEM = {
0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x03, 0x80, 
	0x00, 0x00, 0x01, 0xc0, 0x07, 0xff, 0xff, 0xe0, 0x07, 0xff, 0xff, 0xe0, 0x06, 0x00, 0x01, 0xc0, 
	0x06, 0x00, 0x03, 0x80, 0x06, 0x00, 0x07, 0x00, 0x06, 0x00, 0x0e, 0x00, 0x06, 0x00, 0x0c, 0x00, 
	0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x60, 
	0x00, 0x30, 0x00, 0x60, 0x00, 0x70, 0x00, 0x60, 0x00, 0xe0, 0x00, 0x60, 0x01, 0xc0, 0x00, 0x60, 
	0x03, 0x80, 0x00, 0x60, 0x07, 0xff, 0xff, 0xe0, 0x07, 0xff, 0xff, 0xe0, 0x03, 0x80, 0x00, 0x00, 
	0x01, 0xc0, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00
};


const unsigned char currentlySmallLoadCell_icon[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xf8, 
	0x00, 0x03, 0xff, 0xfc, 0x00, 0x06, 0x00, 0x06, 0x00, 0x06, 0x00, 0x06, 0x00, 0x06, 0x00, 0x06, 
	0x00, 0x06, 0x00, 0x06, 0x00, 0x06, 0x00, 0x06, 0x00, 0x06, 0x00, 0x06, 0x00, 0x06, 0x00, 0x06, 
	0x00, 0x06, 0x00, 0x06, 0x00, 0x06, 0x00, 0x06, 0x00, 0x06, 0x00, 0x06, 0x00, 0x06, 0x00, 0x06, 
	0x00, 0x06, 0x00, 0x06, 0x00, 0x06, 0x00, 0x06, 0x00, 0x06, 0x00, 0x06, 0x00, 0x03, 0xff, 0xfc, 
	0x00, 0x01, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  };


const unsigned char currentlyBigLoadCell_icon[] PROGMEM = {
  0x1f, 0xff, 0xff, 0xf8, 0x3f, 0xff, 0xff, 0xfc, 0x7f, 0xff, 0xff, 0xfe, 0xe0, 0x00, 0x00, 0x07, 
	0xe0, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 
	0xe0, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 
	0xe0, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 
	0xe0, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 
	0xe0, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 
	0xe0, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x07, 
	0xe0, 0x00, 0x00, 0x07, 0x7f, 0xff, 0xff, 0xfe, 0x3f, 0xff, 0xff, 0xfc, 0x1f, 0xff, 0xff, 0xf8
};
const int bigScale_calVal_eepromAdress = 0;
const int smallScale_calVal_eepromAdress = 0;
unsigned long t = 0;
volatile boolean bigScale_newDataReady;
volatile boolean smallScale_newDataReady;
float previousValue = 0;
boolean powerStatus = true; //false for off

//interrupt routine:
void toggle_power() {
  if (!powerStatus) {
    powerStatus = true;
    swapLoadCell(currentLoadCell);
  } else {
    powerStatus = false;
    BigCell.powerDown();
    SmallCell.powerDown();
    screen.clearDisplay();
  }
}
boolean tareAndWait = false;
//interrupt routine:
void tare_buttonISR() {
  tareAndWait = true;
}

//interrupt routine:
void swapLoadCell_buttonISR() {
  if (currentLoadCell == bigLoadCell) swapLoadCell(smallLoadCell);
  else swapLoadCell(bigLoadCell);
 
}

//interrupt routine:
void sendData_buttonISR() {
  Serial.println("send");
}



//interrupt routine:
void bigScale_dataReadyISR() {
  if (BigCell.update()) {
    bigScale_newDataReady = 1;
  }
}

//interrupt routine:
void smallScale_dataReadyISR() {
  if (SmallCell.update()) {
    smallScale_newDataReady = 1;
  }
}

void setup() {

  pinMode(BIG_SCALE_HX711_dout, INPUT);
  pinMode(BIG_SCALE_HX711_sck, OUTPUT);
  pinMode(SMALL_SCALE_HX711_dout, INPUT);
  pinMode(SMALL_SCALE_HX711_sck, OUTPUT);

  screen.begin(SSD1306_SWITCHCAPVCC, SCREEN_I2C_ADDRESS);
  screen.clearDisplay();
  screen.setTextColor(WHITE);
  screen.setTextSize(2);
  screen.setCursor(0,0);
  drawHeader();
  screen.display();

    Serial.begin(115200); delay(10);
    float BigCell_calibrationValue; 
    BigCell_calibrationValue = 1868.20;

    float smallScale_calibrationValue; 
    smallScale_calibrationValue = 10348.32; 
    
    #if defined(ESP8266) || defined(ESP32)
    //EEPROM.begin(512); // uncomment this if you use ESP8266 and want to fetch the value from eeprom
    #endif
    //EEPROM.get(calVal_eepromAdress, BigCell_calibrationValue); // uncomment this if you want to fetch the value from eeprom

    BigCell.begin();
    SmallCell.begin();
    //LoadCell.setReverseOutput();

    unsigned long stabilizingtime = 2000; // tare preciscion can be improved by adding a few seconds of stabilizing time

    boolean _tare = true; //set this to false if you don't want tare to be performed in the next step
    BigCell.start(stabilizingtime, _tare);

    if (BigCell.getTareTimeoutFlag()) {
        Serial.println("Timeout, big loadCell failed to initialize check wiring");
        while (1);
    } else {
        BigCell.setCalFactor(BigCell_calibrationValue); // set calibration value (float)
        Serial.println("Startup is complete");
    }
    
    SmallCell.start(stabilizingtime, _tare);
    if (SmallCell.getTareTimeoutFlag()) {
        Serial.println("Timeout, small loadCell failed to initialize check wiring");
        while (1);
    } else {
        SmallCell.setCalFactor(smallScale_calibrationValue); // set calibration value (float)
        Serial.println("Startup is complete");
    }
    swapLoadCell(currentLoadCell);
    attachInterrupt(digitalPinToInterrupt(BIG_SCALE_HX711_dout), bigScale_dataReadyISR, FALLING);
    attachInterrupt(digitalPinToInterrupt(SMALL_SCALE_HX711_dout), smallScale_dataReadyISR, FALLING);
    attachInterrupt(digitalPinToInterrupt(sendDataPin), sendData_buttonISR , RISING);
    attachInterrupt(digitalPinToInterrupt(swapLoadCellPin), swapLoadCell_buttonISR, RISING);
    attachInterrupt(digitalPinToInterrupt(powerPin), toggle_power , RISING);
    attachInterrupt(digitalPinToInterrupt(tarePin), tare_buttonISR , RISING);

}

void loop() {

  if (tareAndWait) {
    if (currentLoadCell == bigLoadCell) BigCell.tare();
    else SmallCell.tare();
    tareAndWait = false;
  }
  if (powerStatus) {
    screen.clearDisplay();
    drawHeader();
    float load;
    switch (currentLoadCell)
    {
    case bigLoadCell:
      load = BigCell.getData();
      bigScale_newDataReady = 0;
      break;
    case smallLoadCell:
      load = SmallCell.getData();
      smallScale_newDataReady = 0;
      break;
    }
    float normalizedValue = 0.8*load + 0.2*previousValue;
    previousValue = normalizedValue;
    screen.setCursor(38, 38);
    //Serial.println(load);
    screen.printf("%.2f", load); screen.print('g');
  }
    screen.display();
  
}

void swapLoadCell(load_cell loadCell){
  if (loadCell == bigLoadCell) {
    currentLoadCell = bigLoadCell;
    BigCell.powerUp();
    SmallCell.powerDown();
  }
  else {
    currentLoadCell = smallLoadCell;
    SmallCell.powerUp();
    BigCell.powerDown();
  }
  screen.clearDisplay();
  drawHeader();
}

void drawHeader(){
  screen.drawBitmap((0*32),0, power_icon, 32,32, WHITE);
  screen.drawBitmap((1*32),0, tare_icon, 32,32, WHITE);
  screen.drawBitmap((2*32),0, swap_cell, 32,32, WHITE);
  if (true) screen.drawBitmap((3*32),0, send_data_icon, 32,32, WHITE); // chech if conected via bluetooth
  else screen.drawBitmap((3*32),0, not_connected_icon, 32,32, WHITE);

  if (currentLoadCell == bigLoadCell) screen.drawBitmap(0, 32, currentlyBigLoadCell_icon, 32, 32, WHITE);
  else screen.drawBitmap(0, 32, currentlySmallLoadCell_icon, 32, 32, WHITE);
}

// tare LoadCell.tareNoDelay();
